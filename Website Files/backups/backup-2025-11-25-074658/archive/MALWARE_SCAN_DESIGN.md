# Async Malware Scanning for Attachments (Design)

This document outlines an asynchronous malware scanning pipeline for support ticket attachments using Google Cloud Functions + Cloud Storage + ClamAV.

## Goals

- Automatically scan uploaded attachments for malware
- Keep user experience responsive (uploads proceed; message posts after upload as today)
- Mark files as safe or quarantine infected files
- Avoid blocking frontend; provide clear status and eventual consistency

## High-level Flow

1. Admin/customer uploads file to Firebase Storage (current implementation).
2. A Cloud Function (Storage onFinalize trigger) is invoked upon object creation at path `tickets/{ticketId}/attachments/{filename}`.
3. The function downloads the object to `/tmp`, updates ClamAV db (or uses pre-baked layer), scans the file.
4. If CLEAN:
   - Set object metadata: `scanStatus=clean`, `scanTimestamp=...`.
   - Optionally move to a `clean/` prefix for segmented access.
5. If INFECTED or ERROR:
   - Set object metadata: `scanStatus=infected` and optionally `scanInfo=<signature>`.
   - Move to a quarantine bucket/prefix: `quarantine/{originalPath}`.
   - Optionally write a Firestore doc: `security/scans/{objectId}` for audit.
6. Frontend can poll metadata or read Firestore to show per-attachment status.

## Storage Layout

- Upload path (current): `tickets/{ticketId}/attachments/{fileName}`
- Optional clean path: `tickets/{ticketId}/clean/{fileName}`
- Quarantine path: `quarantine/tickets/{ticketId}/{fileName}`

## Object Metadata

On the object:

- `scanStatus`: `pending` | `clean` | `infected` | `error`
- `scanEngine`: `clamav`
- `scanTimestamp`: ISO string
- `scanInfo`: optional signature or error detail

Front-end can render badges accordingly. Initial uploads can set `scanStatus=pending` by client, then function updates.

## Cloud Function (Node 18) Sketch

```ts
// functions/src/scanAttachment.ts
import { onObjectFinalized } from "firebase-functions/v2/storage";
import { Storage } from "@google-cloud/storage";
import { tmpdir } from "os";
import { join } from "path";
import { promises as fs } from "fs";
import { execFile } from "child_process";
import { promisify } from "util";

const storage = new Storage();
const exec = promisify(execFile);

export const scanAttachment = onObjectFinalized(
  { bucket: process.env.FUNCTIONS_EMULATOR ? undefined : undefined },
  async (event) => {
    const bucketName = event.bucket;
    const name = event.name || "";
    if (!name.startsWith("tickets/")) return; // ignore other paths

    const bucket = storage.bucket(bucketName);
    const file = bucket.file(name);
    const tmpPath = join(tmpdir(), name.split("/").pop() || "upload");

    try {
      // download file
      await fs.mkdir(join(tmpdir(), "tickets"), { recursive: true });
      await file.download({ destination: tmpPath });

      // update AV db (optional if using a layer or prebuilt image)
      // await exec('freshclam');

      // scan
      const { stdout } = await exec("clamscan", ["-i", tmpPath]);
      const infected = /FOUND$/m.test(stdout);

      if (infected) {
        const quarantine = bucket.file(`quarantine/${name}`);
        await file.move(quarantine);
        await quarantine.setMetadata({
          metadata: {
            scanStatus: "infected",
            scanEngine: "clamav",
            scanTimestamp: new Date().toISOString(),
          },
        });
        return;
      }

      // clean
      await file.setMetadata({
        metadata: {
          scanStatus: "clean",
          scanEngine: "clamav",
          scanTimestamp: new Date().toISOString(),
        },
      });
    } catch (err) {
      await file.setMetadata({
        metadata: {
          scanStatus: "error",
          scanEngine: "clamav",
          scanTimestamp: new Date().toISOString(),
        },
      });
    } finally {
      try {
        await fs.unlink(tmpPath);
      } catch {}
    }
  }
);
```

Notes:

- Use a custom container or layer that bundles ClamAV for faster cold starts.
- Limit scanned file size (e.g., up to 25–50 MB) to control cost/time.
- Consider Pub/Sub + Workflows if you need retries or multi-engine scans.

## Frontend Integration

- Current client already performs basic signature checks (not a substitute).
- After upload, show a small badge on attachments: `Pending scan`, `Clean`, `Blocked`.
- Poll Storage object metadata or mirror to Firestore for real-time updates.

## Security

- Service account for Functions must have read/write to Storage buckets.
- Deny direct downloads from `quarantine/` via Security Rules.
- Consider signed URLs with short TTL for downloads only when `scanStatus=clean`.

## Cost and Ops

- ClamAV DB updates can be cached in the container image or via EFS-like approach.
- Monitor function execution timeouts; set memory ~1–2 GB for scans if needed.
- Add logs and metrics to detect spikes (possible attack via large uploads).
